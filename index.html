<!DOCTYPE html>
<html>
<head>
    <title>Ecosystem Simulation</title>
</head>
<!--Load the AJAX API-->
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
<script type="text/javascript">

</script>

<body>
<script type="module" src="/js/threeStarter.js"></script>
<script src="/js/app.js"></script>
<script src="js/util/perlinNoise.js"></script>
<script src="js/util/chartDrawer.js"></script>
<script src="js/parameters.js"></script>
<script src="js/library/dat.gui.min.js"></script>
<script src="js/gui/gui.js"></script>
<script src="js/world/World.js"></script>
<script src="js/world/ObjectBases.js"></script>
<script id="vertexShader" type="x-shader/x-vertex" src="shader.vert">
    varying vec2 vUv;
    varying vec3 vNormal;
    varying vec3 vPosition;
    void main() {
        vUv = uv;

        vNormal = (modelViewMatrix * vec4(normal, 0.0)).xyz;
        vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;


        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
</script>
<script id="fragmentShader" type="x-shader/x-fragment">
    struct PointLight {
        vec3 color;
        vec3 position;
        float distance;
    };
    uniform PointLight pointLights[NUM_POINT_LIGHTS];

    varying vec3 vNormal;
    varying vec3 vPosition;
    uniform vec3 color;
    varying vec2 vUv;
    void main() {

        vec4 addedLights = vec4(0.0,
        0.0,
        0.0,
        1.0);
        for (int l = 0; l < NUM_POINT_LIGHTS; l++) {
            vec3 lightDirection = normalize(vPosition - pointLights[l].position);
            addedLights.rgb += clamp(dot(-lightDirection, vNormal), 0.0, 1.0)
            * pointLights[l].color;
        }
        addedLights = max(vec4(0.3), addedLights);

        gl_FragColor = vec4(color, 1.)*addedLights;
    }
</script>
</body>
</html>